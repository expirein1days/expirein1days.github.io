{"version":3,"sources":["../node_modules/blueimp-load-image/js/load-image-scale.js","../node_modules/blueimp-load-image/js/load-image-exif.js","../node_modules/blueimp-load-image/js/load-image-iptc.js","../node_modules/blueimp-load-image/js/index.js","../node_modules/blueimp-load-image/js/load-image-fetch.js","../node_modules/blueimp-load-image/js/load-image-exif-map.js","../node_modules/blueimp-load-image/js/load-image-iptc-map.js","../node_modules/blueimp-load-image/js/load-image-orientation.js","../node_modules/blueimp-load-image/js/load-image.js","../node_modules/blueimp-load-image/js/load-image-meta.js"],"names":["__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","__webpack_require__","undefined","loadImage","originalTransform","transform","img","options","callback","file","data","call","scale","transformCoordinates","getTransformedOptions","newOptions","i","width","height","aspectRatio","hasOwnProperty","crop","naturalWidth","naturalHeight","maxWidth","maxHeight","renderImageToCanvas","canvas","sourceX","sourceY","sourceWidth","sourceHeight","destX","destY","destWidth","destHeight","getContext","drawImage","hasCanvasOption","minWidth","minHeight","pixelRatio","downsamplingRatio","tmp","document","createElement","useCanvas","scaleUp","Math","max","scaleDown","min","left","top","right","bottom","contain","cover","style","apply","exports","module","ExifMap","this","prototype","map","Orientation","get","id","getExifThumbnail","dataView","offset","length","byteLength","createObjectURL","Blob","buffer","slice","console","log","exifTagTypes","1","getValue","dataOffset","getUint8","size","2","String","fromCharCode","ascii","3","littleEndian","getUint16","4","getUint32","5","9","getInt32","10","getExifValue","tiffOffset","type","tagSize","values","str","c","tagType","parseExifTag","tag","exif","parseExifTags","dirOffset","tagsNumber","dirEndOffset","parseExifData","disableExif","thumbnailData","disableExifThumbnail","Thumbnail","disableExifSub","disableExifGps","metaDataParsers","jpeg","push","IptcMap","ObjectName","parseIptcTags","startOffset","sectionLength","getStringFromDB","start","outstr","n","fieldValue","dataSize","segmentType","segmentStartPos","iptc","tags","getInt16","Array","parseIptcData","disableIptc","markerLength","isFieldSegmentStart","nameHeaderLength","fetch","Request","fetchBlob","url","hasMetaOption","then","response","blob","catch","err","256","257","34665","34853","40965","258","259","262","274","277","284","530","531","282","283","296","273","278","279","513","514","301","318","319","529","532","306","270","271","272","305","315","33432","36864","40960","40961","40962","40963","42240","37121","37122","37500","37510","40964","36867","36868","37520","37521","37522","33434","33437","34850","34852","34855","34856","34864","34865","34866","34867","34868","34869","37377","37378","37379","37380","37381","37382","37383","37384","37385","37396","37386","41483","41484","41486","41487","41488","41492","41493","41495","41728","41729","41730","41985","41986","41987","41988","41989","41990","41991","41992","41993","41994","41995","41996","42016","42032","42033","42034","42035","42036","42037","0","6","7","8","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","stringValues","ExposureProgram","MeteringMode","255","LightSource","Flash","32","65","69","71","73","77","79","89","93","95","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","ComponentsConfiguration","getText","value","exifMapPrototype","prop","getAll","35","37","38","40","42","45","47","50","55","60","62","63","70","75","80","85","90","92","100","101","103","105","110","115","116","118","120","122","130","131","135","iptcMapPrototype","originalHasCanvasOption","originalHasMetaOption","originalTransformCoordinates","originalGetTransformedOptions","orientation","ctx","styleWidth","styleHeight","translate","rotate","PI","opts","$","onerror","event","onload","crossOrigin","src","isInstanceOf","_objectURL","readFile","e","target","result","urlAPI","URL","revokeObjectURL","webkitURL","revokeHelper","noRevoke","obj","Object","toString","originalWidth","originalHeight","method","FileReader","fileReader","window","hasblobSlice","webkitSlice","mozSlice","blobSlice","arguments","65505","65517","parseMetaData","that","maxMetaDataSize","noMetaData","DataView","error","markerBytes","parsers","maxOffset","headLength","disableImageHead","imageHead","Uint8Array","subarray","meta"],"mappings":"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","file":"static/js/16.35dc71cd.chunk.js","sourcesContent":["/*\n * JavaScript Load Image Scaling\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var originalTransform = loadImage.transform;\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    originalTransform.call(loadImage, loadImage.scale(img, options, data), options, callback, file, data);\n  }; // Transform image coordinates, allows to override e.g.\n  // the canvas orientation based on the orientation option,\n  // gets canvas, options passed as arguments:\n\n\n  loadImage.transformCoordinates = function () {}; // Returns transformed options, allows to override e.g.\n  // maxWidth, maxHeight and crop options based on the aspectRatio.\n  // gets img, options passed as arguments:\n\n\n  loadImage.getTransformedOptions = function (img, options) {\n    var aspectRatio = options.aspectRatio;\n    var newOptions;\n    var i;\n    var width;\n    var height;\n\n    if (!aspectRatio) {\n      return options;\n    }\n\n    newOptions = {};\n\n    for (i in options) {\n      if (options.hasOwnProperty(i)) {\n        newOptions[i] = options[i];\n      }\n    }\n\n    newOptions.crop = true;\n    width = img.naturalWidth || img.width;\n    height = img.naturalHeight || img.height;\n\n    if (width / height > aspectRatio) {\n      newOptions.maxWidth = height * aspectRatio;\n      newOptions.maxHeight = height;\n    } else {\n      newOptions.maxWidth = width;\n      newOptions.maxHeight = width / aspectRatio;\n    }\n\n    return newOptions;\n  }; // Canvas render method, allows to implement a different rendering algorithm:\n\n\n  loadImage.renderImageToCanvas = function (canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {\n    canvas.getContext('2d').drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);\n    return canvas;\n  }; // Determines if the target image should be a canvas element:\n\n\n  loadImage.hasCanvasOption = function (options) {\n    return options.canvas || options.crop || !!options.aspectRatio;\n  }; // Scales and/or crops the given image (img or canvas HTML element)\n  // using the given options.\n  // Returns a canvas object if the browser supports canvas\n  // and the hasCanvasOption method returns true or a canvas\n  // object is passed as image, else the scaled image:\n\n\n  loadImage.scale = function (img, options, data) {\n    options = options || {};\n    var canvas = document.createElement('canvas');\n    var useCanvas = img.getContext || loadImage.hasCanvasOption(options) && canvas.getContext;\n    var width = img.naturalWidth || img.width;\n    var height = img.naturalHeight || img.height;\n    var destWidth = width;\n    var destHeight = height;\n    var maxWidth;\n    var maxHeight;\n    var minWidth;\n    var minHeight;\n    var sourceWidth;\n    var sourceHeight;\n    var sourceX;\n    var sourceY;\n    var pixelRatio;\n    var downsamplingRatio;\n    var tmp;\n\n    function scaleUp() {\n      var scale = Math.max((minWidth || destWidth) / destWidth, (minHeight || destHeight) / destHeight);\n\n      if (scale > 1) {\n        destWidth *= scale;\n        destHeight *= scale;\n      }\n    }\n\n    function scaleDown() {\n      var scale = Math.min((maxWidth || destWidth) / destWidth, (maxHeight || destHeight) / destHeight);\n\n      if (scale < 1) {\n        destWidth *= scale;\n        destHeight *= scale;\n      }\n    }\n\n    if (useCanvas) {\n      options = loadImage.getTransformedOptions(img, options, data);\n      sourceX = options.left || 0;\n      sourceY = options.top || 0;\n\n      if (options.sourceWidth) {\n        sourceWidth = options.sourceWidth;\n\n        if (options.right !== undefined && options.left === undefined) {\n          sourceX = width - sourceWidth - options.right;\n        }\n      } else {\n        sourceWidth = width - sourceX - (options.right || 0);\n      }\n\n      if (options.sourceHeight) {\n        sourceHeight = options.sourceHeight;\n\n        if (options.bottom !== undefined && options.top === undefined) {\n          sourceY = height - sourceHeight - options.bottom;\n        }\n      } else {\n        sourceHeight = height - sourceY - (options.bottom || 0);\n      }\n\n      destWidth = sourceWidth;\n      destHeight = sourceHeight;\n    }\n\n    maxWidth = options.maxWidth;\n    maxHeight = options.maxHeight;\n    minWidth = options.minWidth;\n    minHeight = options.minHeight;\n\n    if (useCanvas && maxWidth && maxHeight && options.crop) {\n      destWidth = maxWidth;\n      destHeight = maxHeight;\n      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight;\n\n      if (tmp < 0) {\n        sourceHeight = maxHeight * sourceWidth / maxWidth;\n\n        if (options.top === undefined && options.bottom === undefined) {\n          sourceY = (height - sourceHeight) / 2;\n        }\n      } else if (tmp > 0) {\n        sourceWidth = maxWidth * sourceHeight / maxHeight;\n\n        if (options.left === undefined && options.right === undefined) {\n          sourceX = (width - sourceWidth) / 2;\n        }\n      }\n    } else {\n      if (options.contain || options.cover) {\n        minWidth = maxWidth = maxWidth || minWidth;\n        minHeight = maxHeight = maxHeight || minHeight;\n      }\n\n      if (options.cover) {\n        scaleDown();\n        scaleUp();\n      } else {\n        scaleUp();\n        scaleDown();\n      }\n    }\n\n    if (useCanvas) {\n      pixelRatio = options.pixelRatio;\n\n      if (pixelRatio > 1) {\n        canvas.style.width = destWidth + 'px';\n        canvas.style.height = destHeight + 'px';\n        destWidth *= pixelRatio;\n        destHeight *= pixelRatio;\n        canvas.getContext('2d').scale(pixelRatio, pixelRatio);\n      }\n\n      downsamplingRatio = options.downsamplingRatio;\n\n      if (downsamplingRatio > 0 && downsamplingRatio < 1 && destWidth < sourceWidth && destHeight < sourceHeight) {\n        while (sourceWidth * downsamplingRatio > destWidth) {\n          canvas.width = sourceWidth * downsamplingRatio;\n          canvas.height = sourceHeight * downsamplingRatio;\n          loadImage.renderImageToCanvas(canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, canvas.width, canvas.height);\n          sourceX = 0;\n          sourceY = 0;\n          sourceWidth = canvas.width;\n          sourceHeight = canvas.height;\n          img = document.createElement('canvas');\n          img.width = sourceWidth;\n          img.height = sourceHeight;\n          loadImage.renderImageToCanvas(img, canvas, 0, 0, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);\n        }\n      }\n\n      canvas.width = destWidth;\n      canvas.height = destHeight;\n      loadImage.transformCoordinates(canvas, options);\n      return loadImage.renderImageToCanvas(canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, destWidth, destHeight);\n    }\n\n    img.width = destWidth;\n    img.height = destHeight;\n    return img;\n  };\n});","/*\n * JavaScript Load Image Exif Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, Blob */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-meta'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-meta'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  loadImage.ExifMap = function () {\n    return this;\n  };\n\n  loadImage.ExifMap.prototype.map = {\n    Orientation: 0x0112\n  };\n\n  loadImage.ExifMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]];\n  };\n\n  loadImage.getExifThumbnail = function (dataView, offset, length) {\n    if (!length || offset + length > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid thumbnail data.');\n      return;\n    }\n\n    return loadImage.createObjectURL(new Blob([dataView.buffer.slice(offset, offset + length)]));\n  };\n\n  loadImage.exifTagTypes = {\n    // byte, 8-bit unsigned int:\n    1: {\n      getValue: function getValue(dataView, dataOffset) {\n        return dataView.getUint8(dataOffset);\n      },\n      size: 1\n    },\n    // ascii, 8-bit byte:\n    2: {\n      getValue: function getValue(dataView, dataOffset) {\n        return String.fromCharCode(dataView.getUint8(dataOffset));\n      },\n      size: 1,\n      ascii: true\n    },\n    // short, 16 bit int:\n    3: {\n      getValue: function getValue(dataView, dataOffset, littleEndian) {\n        return dataView.getUint16(dataOffset, littleEndian);\n      },\n      size: 2\n    },\n    // long, 32 bit int:\n    4: {\n      getValue: function getValue(dataView, dataOffset, littleEndian) {\n        return dataView.getUint32(dataOffset, littleEndian);\n      },\n      size: 4\n    },\n    // rational = two long values, first is numerator, second is denominator:\n    5: {\n      getValue: function getValue(dataView, dataOffset, littleEndian) {\n        return dataView.getUint32(dataOffset, littleEndian) / dataView.getUint32(dataOffset + 4, littleEndian);\n      },\n      size: 8\n    },\n    // slong, 32 bit signed int:\n    9: {\n      getValue: function getValue(dataView, dataOffset, littleEndian) {\n        return dataView.getInt32(dataOffset, littleEndian);\n      },\n      size: 4\n    },\n    // srational, two slongs, first is numerator, second is denominator:\n    10: {\n      getValue: function getValue(dataView, dataOffset, littleEndian) {\n        return dataView.getInt32(dataOffset, littleEndian) / dataView.getInt32(dataOffset + 4, littleEndian);\n      },\n      size: 8\n    } // undefined, 8-bit byte, value depending on field:\n\n  };\n  loadImage.exifTagTypes[7] = loadImage.exifTagTypes[1];\n\n  loadImage.getExifValue = function (dataView, tiffOffset, offset, type, length, littleEndian) {\n    var tagType = loadImage.exifTagTypes[type];\n    var tagSize;\n    var dataOffset;\n    var values;\n    var i;\n    var str;\n    var c;\n\n    if (!tagType) {\n      console.log('Invalid Exif data: Invalid tag type.');\n      return;\n    }\n\n    tagSize = tagType.size * length; // Determine if the value is contained in the dataOffset bytes,\n    // or if the value at the dataOffset is a pointer to the actual data:\n\n    dataOffset = tagSize > 4 ? tiffOffset + dataView.getUint32(offset + 8, littleEndian) : offset + 8;\n\n    if (dataOffset + tagSize > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid data offset.');\n      return;\n    }\n\n    if (length === 1) {\n      return tagType.getValue(dataView, dataOffset, littleEndian);\n    }\n\n    values = [];\n\n    for (i = 0; i < length; i += 1) {\n      values[i] = tagType.getValue(dataView, dataOffset + i * tagType.size, littleEndian);\n    }\n\n    if (tagType.ascii) {\n      str = ''; // Concatenate the chars:\n\n      for (i = 0; i < values.length; i += 1) {\n        c = values[i]; // Ignore the terminating NULL byte(s):\n\n        if (c === \"\\0\") {\n          break;\n        }\n\n        str += c;\n      }\n\n      return str;\n    }\n\n    return values;\n  };\n\n  loadImage.parseExifTag = function (dataView, tiffOffset, offset, littleEndian, data) {\n    var tag = dataView.getUint16(offset, littleEndian);\n    data.exif[tag] = loadImage.getExifValue(dataView, tiffOffset, offset, dataView.getUint16(offset + 2, littleEndian), // tag type\n    dataView.getUint32(offset + 4, littleEndian), // tag length\n    littleEndian);\n  };\n\n  loadImage.parseExifTags = function (dataView, tiffOffset, dirOffset, littleEndian, data) {\n    var tagsNumber, dirEndOffset, i;\n\n    if (dirOffset + 6 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory offset.');\n      return;\n    }\n\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian);\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber;\n\n    if (dirEndOffset + 4 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory size.');\n      return;\n    }\n\n    for (i = 0; i < tagsNumber; i += 1) {\n      this.parseExifTag(dataView, tiffOffset, dirOffset + 2 + 12 * i, // tag offset\n      littleEndian, data);\n    } // Return the offset to the next directory:\n\n\n    return dataView.getUint32(dirEndOffset, littleEndian);\n  };\n\n  loadImage.parseExifData = function (dataView, offset, length, data, options) {\n    if (options.disableExif) {\n      return;\n    }\n\n    var tiffOffset = offset + 10;\n    var littleEndian;\n    var dirOffset;\n    var thumbnailData; // Check for the ASCII code for \"Exif\" (0x45786966):\n\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\n      // No Exif data, might be XMP data instead\n      return;\n    }\n\n    if (tiffOffset + 8 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid segment size.');\n      return;\n    } // Check for the two null bytes:\n\n\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\n      console.log('Invalid Exif data: Missing byte alignment offset.');\n      return;\n    } // Check the byte alignment:\n\n\n    switch (dataView.getUint16(tiffOffset)) {\n      case 0x4949:\n        littleEndian = true;\n        break;\n\n      case 0x4d4d:\n        littleEndian = false;\n        break;\n\n      default:\n        console.log('Invalid Exif data: Invalid byte alignment marker.');\n        return;\n    } // Check for the TIFF tag marker (0x002A):\n\n\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\n      console.log('Invalid Exif data: Missing TIFF marker.');\n      return;\n    } // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\n\n\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian); // Create the exif object to store the tags:\n\n    data.exif = new loadImage.ExifMap(); // Parse the tags of the main image directory and retrieve the\n    // offset to the next directory, usually the thumbnail directory:\n\n    dirOffset = loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + dirOffset, littleEndian, data);\n\n    if (dirOffset && !options.disableExifThumbnail) {\n      thumbnailData = {\n        exif: {}\n      };\n      dirOffset = loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + dirOffset, littleEndian, thumbnailData); // Check for JPEG Thumbnail offset:\n\n      if (thumbnailData.exif[0x0201]) {\n        data.exif.Thumbnail = loadImage.getExifThumbnail(dataView, tiffOffset + thumbnailData.exif[0x0201], thumbnailData.exif[0x0202] // Thumbnail data length\n        );\n      }\n    } // Check for Exif Sub IFD Pointer:\n\n\n    if (data.exif[0x8769] && !options.disableExifSub) {\n      loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + data.exif[0x8769], // directory offset\n      littleEndian, data);\n    } // Check for GPS Info IFD Pointer:\n\n\n    if (data.exif[0x8825] && !options.disableExifGps) {\n      loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + data.exif[0x8825], // directory offset\n      littleEndian, data);\n    }\n  }; // Registers the Exif parser for the APP1 JPEG meta data segment:\n\n\n  loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData); // Adds the following properties to the parseMetaData callback data:\n  // * exif: The exif tags, parsed by the parseExifData method\n  // Adds the following options to the parseMetaData method:\n  // * disableExif: Disables Exif parsing.\n  // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.\n  // * disableExifSub: Disables parsing of the Exif Sub IFD.\n  // * disableExifGps: Disables parsing of the Exif GPS Info IFD.\n});","/*\n * JavaScript Load Image IPTC Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-meta'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-meta'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  loadImage.IptcMap = function () {\n    return this;\n  };\n\n  loadImage.IptcMap.prototype.map = {\n    ObjectName: 0x5\n  };\n\n  loadImage.IptcMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]];\n  };\n\n  loadImage.parseIptcTags = function (dataView, startOffset, sectionLength, data) {\n    function getStringFromDB(buffer, start, length) {\n      var outstr = '';\n\n      for (var n = start; n < start + length; n++) {\n        outstr += String.fromCharCode(buffer.getUint8(n));\n      }\n\n      return outstr;\n    }\n\n    var fieldValue, dataSize, segmentType;\n    var segmentStartPos = startOffset;\n\n    while (segmentStartPos < startOffset + sectionLength) {\n      // we currently handle the 2: class of iptc tag\n      if (dataView.getUint8(segmentStartPos) === 0x1c && dataView.getUint8(segmentStartPos + 1) === 0x02) {\n        segmentType = dataView.getUint8(segmentStartPos + 2); // only store data for known tags\n\n        if (segmentType in data.iptc.tags) {\n          dataSize = dataView.getInt16(segmentStartPos + 3);\n          fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize); // Check if we already stored a value with this name\n\n          if (data.iptc.hasOwnProperty(segmentType)) {\n            // Value already stored with this name, create multivalue field\n            if (data.iptc[segmentType] instanceof Array) {\n              data.iptc[segmentType].push(fieldValue);\n            } else {\n              data.iptc[segmentType] = [data.iptc[segmentType], fieldValue];\n            }\n          } else {\n            data.iptc[segmentType] = fieldValue;\n          }\n        }\n      }\n\n      segmentStartPos++;\n    }\n  };\n\n  loadImage.parseIptcData = function (dataView, offset, length, data, options) {\n    if (options.disableIptc) {\n      return;\n    }\n\n    var markerLength = offset + length; // Found '8BIM<EOT><EOT>' ?\n\n    var isFieldSegmentStart = function isFieldSegmentStart(dataView, offset) {\n      return dataView.getUint32(offset) === 0x3842494d && dataView.getUint16(offset + 4) === 0x0404;\n    }; // Hunt forward, looking for the correct IPTC block signature:\n    // Reference: https://metacpan.org/pod/distribution/Image-MetaData-JPEG/lib/Image/MetaData/JPEG/Structures.pod#Structure-of-a-Photoshop-style-APP13-segment\n    // From https://github.com/exif-js/exif-js/blob/master/exif.js ~ line 474 on\n\n\n    while (offset + 8 < markerLength) {\n      if (isFieldSegmentStart(dataView, offset)) {\n        var nameHeaderLength = dataView.getUint8(offset + 7);\n        if (nameHeaderLength % 2 !== 0) nameHeaderLength += 1; // Check for pre photoshop 6 format\n\n        if (nameHeaderLength === 0) {\n          // Always 4\n          nameHeaderLength = 4;\n        }\n\n        var startOffset = offset + 8 + nameHeaderLength;\n\n        if (startOffset > markerLength) {\n          console.log('Invalid IPTC data: Invalid segment offset.');\n          break;\n        }\n\n        var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n\n        if (offset + sectionLength > markerLength) {\n          console.log('Invalid IPTC data: Invalid segment size.');\n          break;\n        } // Create the iptc object to store the tags:\n\n\n        data.iptc = new loadImage.IptcMap(); // Parse the tags\n\n        return loadImage.parseIptcTags(dataView, startOffset, sectionLength, data);\n      }\n\n      offset++;\n    }\n\n    console.log('No IPTC data at this offset - could be XMP');\n  }; // Registers this IPTC parser for the APP13 JPEG meta data segment:\n\n\n  loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData); // Adds the following properties to the parseMetaData callback data:\n  // * iptc: The iptc tags, parsed by the parseIptcData method\n  // Adds the following options to the parseMetaData method:\n  // * disableIptc: Disables IPTC parsing.\n});","module.exports = require('./load-image');\n\nrequire('./load-image-scale');\n\nrequire('./load-image-meta');\n\nrequire('./load-image-fetch');\n\nrequire('./load-image-exif');\n\nrequire('./load-image-exif-map');\n\nrequire('./load-image-iptc');\n\nrequire('./load-image-iptc-map');\n\nrequire('./load-image-orientation');","/*\n * JavaScript Load Image Fetch\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2017, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, fetch, Request */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-meta'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-meta'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  if (typeof fetch !== 'undefined' && typeof Request !== 'undefined') {\n    loadImage.fetchBlob = function (url, callback, options) {\n      if (loadImage.hasMetaOption(options)) {\n        return fetch(new Request(url, options)).then(function (response) {\n          return response.blob();\n        }).then(callback).catch(function (err) {\n          console.log(err);\n          callback();\n        });\n      } else {\n        callback();\n      }\n    };\n  }\n});","/*\n * JavaScript Load Image Exif Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Exif tags mapping based on\n * https://github.com/jseidelin/exif-js\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-exif'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-exif'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  loadImage.ExifMap.prototype.tags = {\n    // =================\n    // TIFF tags (IFD0):\n    // =================\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageHeight',\n    0x8769: 'ExifIFDPointer',\n    0x8825: 'GPSInfoIFDPointer',\n    0xa005: 'InteroperabilityIFDPointer',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0112: 'Orientation',\n    0x0115: 'SamplesPerPixel',\n    0x011c: 'PlanarConfiguration',\n    0x0212: 'YCbCrSubSampling',\n    0x0213: 'YCbCrPositioning',\n    0x011a: 'XResolution',\n    0x011b: 'YResolution',\n    0x0128: 'ResolutionUnit',\n    0x0111: 'StripOffsets',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x0201: 'JPEGInterchangeFormat',\n    0x0202: 'JPEGInterchangeFormatLength',\n    0x012d: 'TransferFunction',\n    0x013e: 'WhitePoint',\n    0x013f: 'PrimaryChromaticities',\n    0x0211: 'YCbCrCoefficients',\n    0x0214: 'ReferenceBlackWhite',\n    0x0132: 'DateTime',\n    0x010e: 'ImageDescription',\n    0x010f: 'Make',\n    0x0110: 'Model',\n    0x0131: 'Software',\n    0x013b: 'Artist',\n    0x8298: 'Copyright',\n    // ==================\n    // Exif Sub IFD tags:\n    // ==================\n    0x9000: 'ExifVersion',\n    // EXIF version\n    0xa000: 'FlashpixVersion',\n    // Flashpix format version\n    0xa001: 'ColorSpace',\n    // Color space information tag\n    0xa002: 'PixelXDimension',\n    // Valid width of meaningful image\n    0xa003: 'PixelYDimension',\n    // Valid height of meaningful image\n    0xa500: 'Gamma',\n    0x9101: 'ComponentsConfiguration',\n    // Information about channels\n    0x9102: 'CompressedBitsPerPixel',\n    // Compressed bits per pixel\n    0x927c: 'MakerNote',\n    // Any desired information written by the manufacturer\n    0x9286: 'UserComment',\n    // Comments by user\n    0xa004: 'RelatedSoundFile',\n    // Name of related sound file\n    0x9003: 'DateTimeOriginal',\n    // Date and time when the original image was generated\n    0x9004: 'DateTimeDigitized',\n    // Date and time when the image was stored digitally\n    0x9290: 'SubSecTime',\n    // Fractions of seconds for DateTime\n    0x9291: 'SubSecTimeOriginal',\n    // Fractions of seconds for DateTimeOriginal\n    0x9292: 'SubSecTimeDigitized',\n    // Fractions of seconds for DateTimeDigitized\n    0x829a: 'ExposureTime',\n    // Exposure time (in seconds)\n    0x829d: 'FNumber',\n    0x8822: 'ExposureProgram',\n    // Exposure program\n    0x8824: 'SpectralSensitivity',\n    // Spectral sensitivity\n    0x8827: 'PhotographicSensitivity',\n    // EXIF 2.3, ISOSpeedRatings in EXIF 2.2\n    0x8828: 'OECF',\n    // Optoelectric conversion factor\n    0x8830: 'SensitivityType',\n    0x8831: 'StandardOutputSensitivity',\n    0x8832: 'RecommendedExposureIndex',\n    0x8833: 'ISOSpeed',\n    0x8834: 'ISOSpeedLatitudeyyy',\n    0x8835: 'ISOSpeedLatitudezzz',\n    0x9201: 'ShutterSpeedValue',\n    // Shutter speed\n    0x9202: 'ApertureValue',\n    // Lens aperture\n    0x9203: 'BrightnessValue',\n    // Value of brightness\n    0x9204: 'ExposureBias',\n    // Exposure bias\n    0x9205: 'MaxApertureValue',\n    // Smallest F number of lens\n    0x9206: 'SubjectDistance',\n    // Distance to subject in meters\n    0x9207: 'MeteringMode',\n    // Metering mode\n    0x9208: 'LightSource',\n    // Kind of light source\n    0x9209: 'Flash',\n    // Flash status\n    0x9214: 'SubjectArea',\n    // Location and area of main subject\n    0x920a: 'FocalLength',\n    // Focal length of the lens in mm\n    0xa20b: 'FlashEnergy',\n    // Strobe energy in BCPS\n    0xa20c: 'SpatialFrequencyResponse',\n    0xa20e: 'FocalPlaneXResolution',\n    // Number of pixels in width direction per FPRUnit\n    0xa20f: 'FocalPlaneYResolution',\n    // Number of pixels in height direction per FPRUnit\n    0xa210: 'FocalPlaneResolutionUnit',\n    // Unit for measuring the focal plane resolution\n    0xa214: 'SubjectLocation',\n    // Location of subject in image\n    0xa215: 'ExposureIndex',\n    // Exposure index selected on camera\n    0xa217: 'SensingMethod',\n    // Image sensor type\n    0xa300: 'FileSource',\n    // Image source (3 == DSC)\n    0xa301: 'SceneType',\n    // Scene type (1 == directly photographed)\n    0xa302: 'CFAPattern',\n    // Color filter array geometric pattern\n    0xa401: 'CustomRendered',\n    // Special processing\n    0xa402: 'ExposureMode',\n    // Exposure mode\n    0xa403: 'WhiteBalance',\n    // 1 = auto white balance, 2 = manual\n    0xa404: 'DigitalZoomRatio',\n    // Digital zoom ratio\n    0xa405: 'FocalLengthIn35mmFilm',\n    0xa406: 'SceneCaptureType',\n    // Type of scene\n    0xa407: 'GainControl',\n    // Degree of overall image gain adjustment\n    0xa408: 'Contrast',\n    // Direction of contrast processing applied by camera\n    0xa409: 'Saturation',\n    // Direction of saturation processing applied by camera\n    0xa40a: 'Sharpness',\n    // Direction of sharpness processing applied by camera\n    0xa40b: 'DeviceSettingDescription',\n    0xa40c: 'SubjectDistanceRange',\n    // Distance to subject\n    0xa420: 'ImageUniqueID',\n    // Identifier assigned uniquely to each image\n    0xa430: 'CameraOwnerName',\n    0xa431: 'BodySerialNumber',\n    0xa432: 'LensSpecification',\n    0xa433: 'LensMake',\n    0xa434: 'LensModel',\n    0xa435: 'LensSerialNumber',\n    // ==============\n    // GPS Info tags:\n    // ==============\n    0x0000: 'GPSVersionID',\n    0x0001: 'GPSLatitudeRef',\n    0x0002: 'GPSLatitude',\n    0x0003: 'GPSLongitudeRef',\n    0x0004: 'GPSLongitude',\n    0x0005: 'GPSAltitudeRef',\n    0x0006: 'GPSAltitude',\n    0x0007: 'GPSTimeStamp',\n    0x0008: 'GPSSatellites',\n    0x0009: 'GPSStatus',\n    0x000a: 'GPSMeasureMode',\n    0x000b: 'GPSDOP',\n    0x000c: 'GPSSpeedRef',\n    0x000d: 'GPSSpeed',\n    0x000e: 'GPSTrackRef',\n    0x000f: 'GPSTrack',\n    0x0010: 'GPSImgDirectionRef',\n    0x0011: 'GPSImgDirection',\n    0x0012: 'GPSMapDatum',\n    0x0013: 'GPSDestLatitudeRef',\n    0x0014: 'GPSDestLatitude',\n    0x0015: 'GPSDestLongitudeRef',\n    0x0016: 'GPSDestLongitude',\n    0x0017: 'GPSDestBearingRef',\n    0x0018: 'GPSDestBearing',\n    0x0019: 'GPSDestDistanceRef',\n    0x001a: 'GPSDestDistance',\n    0x001b: 'GPSProcessingMethod',\n    0x001c: 'GPSAreaInformation',\n    0x001d: 'GPSDateStamp',\n    0x001e: 'GPSDifferential',\n    0x001f: 'GPSHPositioningError'\n  };\n  loadImage.ExifMap.prototype.stringValues = {\n    ExposureProgram: {\n      0: 'Undefined',\n      1: 'Manual',\n      2: 'Normal program',\n      3: 'Aperture priority',\n      4: 'Shutter priority',\n      5: 'Creative program',\n      6: 'Action program',\n      7: 'Portrait mode',\n      8: 'Landscape mode'\n    },\n    MeteringMode: {\n      0: 'Unknown',\n      1: 'Average',\n      2: 'CenterWeightedAverage',\n      3: 'Spot',\n      4: 'MultiSpot',\n      5: 'Pattern',\n      6: 'Partial',\n      255: 'Other'\n    },\n    LightSource: {\n      0: 'Unknown',\n      1: 'Daylight',\n      2: 'Fluorescent',\n      3: 'Tungsten (incandescent light)',\n      4: 'Flash',\n      9: 'Fine weather',\n      10: 'Cloudy weather',\n      11: 'Shade',\n      12: 'Daylight fluorescent (D 5700 - 7100K)',\n      13: 'Day white fluorescent (N 4600 - 5400K)',\n      14: 'Cool white fluorescent (W 3900 - 4500K)',\n      15: 'White fluorescent (WW 3200 - 3700K)',\n      17: 'Standard light A',\n      18: 'Standard light B',\n      19: 'Standard light C',\n      20: 'D55',\n      21: 'D65',\n      22: 'D75',\n      23: 'D50',\n      24: 'ISO studio tungsten',\n      255: 'Other'\n    },\n    Flash: {\n      0x0000: 'Flash did not fire',\n      0x0001: 'Flash fired',\n      0x0005: 'Strobe return light not detected',\n      0x0007: 'Strobe return light detected',\n      0x0009: 'Flash fired, compulsory flash mode',\n      0x000d: 'Flash fired, compulsory flash mode, return light not detected',\n      0x000f: 'Flash fired, compulsory flash mode, return light detected',\n      0x0010: 'Flash did not fire, compulsory flash mode',\n      0x0018: 'Flash did not fire, auto mode',\n      0x0019: 'Flash fired, auto mode',\n      0x001d: 'Flash fired, auto mode, return light not detected',\n      0x001f: 'Flash fired, auto mode, return light detected',\n      0x0020: 'No flash function',\n      0x0041: 'Flash fired, red-eye reduction mode',\n      0x0045: 'Flash fired, red-eye reduction mode, return light not detected',\n      0x0047: 'Flash fired, red-eye reduction mode, return light detected',\n      0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',\n      0x004d: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\n      0x004f: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\n      0x0059: 'Flash fired, auto mode, red-eye reduction mode',\n      0x005d: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',\n      0x005f: 'Flash fired, auto mode, return light detected, red-eye reduction mode'\n    },\n    SensingMethod: {\n      1: 'Undefined',\n      2: 'One-chip color area sensor',\n      3: 'Two-chip color area sensor',\n      4: 'Three-chip color area sensor',\n      5: 'Color sequential area sensor',\n      7: 'Trilinear sensor',\n      8: 'Color sequential linear sensor'\n    },\n    SceneCaptureType: {\n      0: 'Standard',\n      1: 'Landscape',\n      2: 'Portrait',\n      3: 'Night scene'\n    },\n    SceneType: {\n      1: 'Directly photographed'\n    },\n    CustomRendered: {\n      0: 'Normal process',\n      1: 'Custom process'\n    },\n    WhiteBalance: {\n      0: 'Auto white balance',\n      1: 'Manual white balance'\n    },\n    GainControl: {\n      0: 'None',\n      1: 'Low gain up',\n      2: 'High gain up',\n      3: 'Low gain down',\n      4: 'High gain down'\n    },\n    Contrast: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    Saturation: {\n      0: 'Normal',\n      1: 'Low saturation',\n      2: 'High saturation'\n    },\n    Sharpness: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    SubjectDistanceRange: {\n      0: 'Unknown',\n      1: 'Macro',\n      2: 'Close view',\n      3: 'Distant view'\n    },\n    FileSource: {\n      3: 'DSC'\n    },\n    ComponentsConfiguration: {\n      0: '',\n      1: 'Y',\n      2: 'Cb',\n      3: 'Cr',\n      4: 'R',\n      5: 'G',\n      6: 'B'\n    },\n    Orientation: {\n      1: 'top-left',\n      2: 'top-right',\n      3: 'bottom-right',\n      4: 'bottom-left',\n      5: 'left-top',\n      6: 'right-top',\n      7: 'right-bottom',\n      8: 'left-bottom'\n    }\n  };\n\n  loadImage.ExifMap.prototype.getText = function (id) {\n    var value = this.get(id);\n\n    switch (id) {\n      case 'LightSource':\n      case 'Flash':\n      case 'MeteringMode':\n      case 'ExposureProgram':\n      case 'SensingMethod':\n      case 'SceneCaptureType':\n      case 'SceneType':\n      case 'CustomRendered':\n      case 'WhiteBalance':\n      case 'GainControl':\n      case 'Contrast':\n      case 'Saturation':\n      case 'Sharpness':\n      case 'SubjectDistanceRange':\n      case 'FileSource':\n      case 'Orientation':\n        return this.stringValues[id][value];\n\n      case 'ExifVersion':\n      case 'FlashpixVersion':\n        if (!value) return;\n        return String.fromCharCode(value[0], value[1], value[2], value[3]);\n\n      case 'ComponentsConfiguration':\n        if (!value) return;\n        return this.stringValues[id][value[0]] + this.stringValues[id][value[1]] + this.stringValues[id][value[2]] + this.stringValues[id][value[3]];\n\n      case 'GPSVersionID':\n        if (!value) return;\n        return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3];\n    }\n\n    return String(value);\n  };\n\n  (function (exifMapPrototype) {\n    var tags = exifMapPrototype.tags;\n    var map = exifMapPrototype.map;\n    var prop; // Map the tag names to tags:\n\n    for (prop in tags) {\n      if (tags.hasOwnProperty(prop)) {\n        map[tags[prop]] = prop;\n      }\n    }\n  })(loadImage.ExifMap.prototype);\n\n  loadImage.ExifMap.prototype.getAll = function () {\n    var map = {};\n    var prop;\n    var id;\n\n    for (prop in this) {\n      if (this.hasOwnProperty(prop)) {\n        id = this.tags[prop];\n\n        if (id) {\n          map[id] = this.getText(id);\n        }\n      }\n    }\n\n    return map;\n  };\n});","/*\n * JavaScript Load Image IPTC Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n *\n * IPTC tags mapping based on\n * https://github.com/jseidelin/exif-js\n * https://iptc.org/standards/photo-metadata\n * http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-iptc'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-iptc'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  loadImage.IptcMap.prototype.tags = {\n    // ==========\n    // IPTC tags:\n    // ==========\n    0x03: 'ObjectType',\n    0x04: 'ObjectAttribute',\n    0x05: 'ObjectName',\n    0x07: 'EditStatus',\n    0x08: 'EditorialUpdate',\n    0x0a: 'Urgency',\n    0x0c: 'SubjectRef',\n    0x0f: 'Category',\n    0x14: 'SupplCategory',\n    0x16: 'FixtureID',\n    0x19: 'Keywords',\n    0x1a: 'ContentLocCode',\n    0x1b: 'ContentLocName',\n    0x1e: 'ReleaseDate',\n    0x23: 'ReleaseTime',\n    0x25: 'ExpirationDate',\n    0x26: 'ExpirationTime',\n    0x28: 'SpecialInstructions',\n    0x2a: 'ActionAdvised',\n    0x2d: 'RefService',\n    0x2f: 'RefDate',\n    0x32: 'RefNumber',\n    0x37: 'DateCreated',\n    0x3c: 'TimeCreated',\n    0x3e: 'DigitalCreationDate',\n    0x3f: 'DigitalCreationTime',\n    0x41: 'OriginatingProgram',\n    0x46: 'ProgramVersion',\n    0x4b: 'ObjectCycle',\n    0x50: 'Byline',\n    0x55: 'BylineTitle',\n    0x5a: 'City',\n    0x5c: 'Sublocation',\n    0x5f: 'State',\n    0x64: 'CountryCode',\n    0x65: 'CountryName',\n    0x67: 'OrigTransRef',\n    0x69: 'Headline',\n    0x6e: 'Credit',\n    0x73: 'Source',\n    0x74: 'CopyrightNotice',\n    0x76: 'Contact',\n    0x78: 'Caption',\n    0x7a: 'WriterEditor',\n    0x82: 'ImageType',\n    0x83: 'ImageOrientation',\n    0x87: 'LanguageID' // We don't record these tags:\n    //\n    // 0x00: 'RecordVersion',\n    // 0x7d: 'RasterizedCaption',\n    // 0x96: 'AudioType',\n    // 0x97: 'AudioSamplingRate',\n    // 0x98: 'AudioSamplingRes',\n    // 0x99: 'AudioDuration',\n    // 0x9a: 'AudioOutcue',\n    // 0xc8: 'PreviewFileFormat',\n    // 0xc9: 'PreviewFileFormatVer',\n    // 0xca: 'PreviewData'\n\n  };\n\n  loadImage.IptcMap.prototype.getText = function (id) {\n    var value = this.get(id);\n    return String(value);\n  };\n\n  (function (iptcMapPrototype) {\n    var tags = iptcMapPrototype.tags;\n    var map = iptcMapPrototype.map || {};\n    var prop; // Map the tag names to tags:\n\n    for (prop in tags) {\n      if (tags.hasOwnProperty(prop)) {\n        map[tags[prop]] = prop;\n      }\n    }\n  })(loadImage.IptcMap.prototype);\n\n  loadImage.IptcMap.prototype.getAll = function () {\n    var map = {};\n    var prop;\n    var id;\n\n    for (prop in this) {\n      if (this.hasOwnProperty(prop)) {\n        id = this.tags[prop];\n\n        if (id) {\n          map[id] = this.getText(id);\n        }\n      }\n    }\n\n    return map;\n  };\n});","/*\n * JavaScript Load Image Orientation\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-scale', './load-image-meta'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-scale'), require('./load-image-meta'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var originalHasCanvasOption = loadImage.hasCanvasOption;\n  var originalHasMetaOption = loadImage.hasMetaOption;\n  var originalTransformCoordinates = loadImage.transformCoordinates;\n  var originalGetTransformedOptions = loadImage.getTransformedOptions; // Determines if the target image should be a canvas element:\n\n  loadImage.hasCanvasOption = function (options) {\n    return !!options.orientation || originalHasCanvasOption.call(loadImage, options);\n  }; // Determines if meta data should be loaded automatically:\n\n\n  loadImage.hasMetaOption = function (options) {\n    return options && options.orientation === true || originalHasMetaOption.call(loadImage, options);\n  }; // Transform image orientation based on\n  // the given EXIF orientation option:\n\n\n  loadImage.transformCoordinates = function (canvas, options) {\n    originalTransformCoordinates.call(loadImage, canvas, options);\n    var ctx = canvas.getContext('2d');\n    var width = canvas.width;\n    var height = canvas.height;\n    var styleWidth = canvas.style.width;\n    var styleHeight = canvas.style.height;\n    var orientation = options.orientation;\n\n    if (!orientation || orientation > 8) {\n      return;\n    }\n\n    if (orientation > 4) {\n      canvas.width = height;\n      canvas.height = width;\n      canvas.style.width = styleHeight;\n      canvas.style.height = styleWidth;\n    }\n\n    switch (orientation) {\n      case 2:\n        // horizontal flip\n        ctx.translate(width, 0);\n        ctx.scale(-1, 1);\n        break;\n\n      case 3:\n        // 180° rotate left\n        ctx.translate(width, height);\n        ctx.rotate(Math.PI);\n        break;\n\n      case 4:\n        // vertical flip\n        ctx.translate(0, height);\n        ctx.scale(1, -1);\n        break;\n\n      case 5:\n        // vertical flip + 90 rotate right\n        ctx.rotate(0.5 * Math.PI);\n        ctx.scale(1, -1);\n        break;\n\n      case 6:\n        // 90° rotate right\n        ctx.rotate(0.5 * Math.PI);\n        ctx.translate(0, -height);\n        break;\n\n      case 7:\n        // horizontal flip + 90 rotate right\n        ctx.rotate(0.5 * Math.PI);\n        ctx.translate(width, -height);\n        ctx.scale(-1, 1);\n        break;\n\n      case 8:\n        // 90° rotate left\n        ctx.rotate(-0.5 * Math.PI);\n        ctx.translate(-width, 0);\n        break;\n    }\n  }; // Transforms coordinate and dimension options\n  // based on the given orientation option:\n\n\n  loadImage.getTransformedOptions = function (img, opts, data) {\n    var options = originalGetTransformedOptions.call(loadImage, img, opts);\n    var orientation = options.orientation;\n    var newOptions;\n    var i;\n\n    if (orientation === true && data && data.exif) {\n      orientation = data.exif.get('Orientation');\n    }\n\n    if (!orientation || orientation > 8 || orientation === 1) {\n      return options;\n    }\n\n    newOptions = {};\n\n    for (i in options) {\n      if (options.hasOwnProperty(i)) {\n        newOptions[i] = options[i];\n      }\n    }\n\n    newOptions.orientation = orientation;\n\n    switch (orientation) {\n      case 2:\n        // horizontal flip\n        newOptions.left = options.right;\n        newOptions.right = options.left;\n        break;\n\n      case 3:\n        // 180° rotate left\n        newOptions.left = options.right;\n        newOptions.top = options.bottom;\n        newOptions.right = options.left;\n        newOptions.bottom = options.top;\n        break;\n\n      case 4:\n        // vertical flip\n        newOptions.top = options.bottom;\n        newOptions.bottom = options.top;\n        break;\n\n      case 5:\n        // vertical flip + 90 rotate right\n        newOptions.left = options.top;\n        newOptions.top = options.left;\n        newOptions.right = options.bottom;\n        newOptions.bottom = options.right;\n        break;\n\n      case 6:\n        // 90° rotate right\n        newOptions.left = options.top;\n        newOptions.top = options.right;\n        newOptions.right = options.bottom;\n        newOptions.bottom = options.left;\n        break;\n\n      case 7:\n        // horizontal flip + 90 rotate right\n        newOptions.left = options.bottom;\n        newOptions.top = options.right;\n        newOptions.right = options.top;\n        newOptions.bottom = options.left;\n        break;\n\n      case 8:\n        // 90° rotate left\n        newOptions.left = options.bottom;\n        newOptions.top = options.left;\n        newOptions.right = options.top;\n        newOptions.bottom = options.right;\n        break;\n    }\n\n    if (newOptions.orientation > 4) {\n      newOptions.maxWidth = options.maxHeight;\n      newOptions.maxHeight = options.maxWidth;\n      newOptions.minWidth = options.minHeight;\n      newOptions.minHeight = options.minWidth;\n      newOptions.sourceWidth = options.sourceHeight;\n      newOptions.sourceHeight = options.sourceWidth;\n    }\n\n    return newOptions;\n  };\n});","/*\n * JavaScript Load Image\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, URL, webkitURL, FileReader */\n;\n\n(function ($) {\n  'use strict'; // Loads an image for a given File object.\n  // Invokes the callback with an img or optional canvas\n  // element (if supported by the browser) as parameter:\n\n  function loadImage(file, callback, options) {\n    var img = document.createElement('img');\n    var url;\n\n    img.onerror = function (event) {\n      return loadImage.onerror(img, event, file, callback, options);\n    };\n\n    img.onload = function (event) {\n      return loadImage.onload(img, event, file, callback, options);\n    };\n\n    if (typeof file === 'string') {\n      loadImage.fetchBlob(file, function (blob) {\n        if (blob) {\n          file = blob;\n          url = loadImage.createObjectURL(file);\n        } else {\n          url = file;\n\n          if (options && options.crossOrigin) {\n            img.crossOrigin = options.crossOrigin;\n          }\n        }\n\n        img.src = url;\n      }, options);\n      return img;\n    } else if (loadImage.isInstanceOf('Blob', file) || // Files are also Blob instances, but some browsers\n    // (Firefox 3.6) support the File API but not Blobs:\n    loadImage.isInstanceOf('File', file)) {\n      url = img._objectURL = loadImage.createObjectURL(file);\n\n      if (url) {\n        img.src = url;\n        return img;\n      }\n\n      return loadImage.readFile(file, function (e) {\n        var target = e.target;\n\n        if (target && target.result) {\n          img.src = target.result;\n        } else if (callback) {\n          callback(e);\n        }\n      });\n    }\n  } // The check for URL.revokeObjectURL fixes an issue with Opera 12,\n  // which provides URL.createObjectURL but doesn't properly implement it:\n\n\n  var urlAPI = $.createObjectURL && $ || $.URL && URL.revokeObjectURL && URL || $.webkitURL && webkitURL;\n\n  function revokeHelper(img, options) {\n    if (img._objectURL && !(options && options.noRevoke)) {\n      loadImage.revokeObjectURL(img._objectURL);\n      delete img._objectURL;\n    }\n  } // If the callback given to this function returns a blob, it is used as image\n  // source instead of the original url and overrides the file argument used in\n  // the onload and onerror event callbacks:\n\n\n  loadImage.fetchBlob = function (url, callback, options) {\n    callback();\n  };\n\n  loadImage.isInstanceOf = function (type, obj) {\n    // Cross-frame instanceof check\n    return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n  };\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    callback(img, data);\n  };\n\n  loadImage.onerror = function (img, event, file, callback, options) {\n    revokeHelper(img, options);\n\n    if (callback) {\n      callback.call(img, event);\n    }\n  };\n\n  loadImage.onload = function (img, event, file, callback, options) {\n    revokeHelper(img, options);\n\n    if (callback) {\n      loadImage.transform(img, options, callback, file, {\n        originalWidth: img.naturalWidth || img.width,\n        originalHeight: img.naturalHeight || img.height\n      });\n    }\n  };\n\n  loadImage.createObjectURL = function (file) {\n    return urlAPI ? urlAPI.createObjectURL(file) : false;\n  };\n\n  loadImage.revokeObjectURL = function (url) {\n    return urlAPI ? urlAPI.revokeObjectURL(url) : false;\n  }; // Loads a given File object via FileReader interface,\n  // invokes the callback with the event object (load or error).\n  // The result can be read via event.target.result:\n\n\n  loadImage.readFile = function (file, callback, method) {\n    if ($.FileReader) {\n      var fileReader = new FileReader();\n      fileReader.onload = fileReader.onerror = callback;\n      method = method || 'readAsDataURL';\n\n      if (fileReader[method]) {\n        fileReader[method](file);\n        return fileReader;\n      }\n    }\n\n    return false;\n  };\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return loadImage;\n    });\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = loadImage;\n  } else {\n    $.loadImage = loadImage;\n  }\n})(typeof window !== 'undefined' && window || this);","/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image meta data handling implementation\n * based on the help and contribution of\n * Achim Stöhr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, Blob */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var hasblobSlice = typeof Blob !== 'undefined' && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\n\n  loadImage.blobSlice = hasblobSlice && function () {\n    var slice = this.slice || this.webkitSlice || this.mozSlice;\n    return slice.apply(this, arguments);\n  };\n\n  loadImage.metaDataParsers = {\n    jpeg: {\n      0xffe1: [],\n      // APP1 marker\n      0xffed: [] // APP13 marker\n\n    } // Parses image meta data and calls the callback with an object argument\n    // with the following properties:\n    // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\n    // The options argument accepts an object and supports the following\n    // properties:\n    // * maxMetaDataSize: Defines the maximum number of bytes to parse.\n    // * disableImageHead: Disables creating the imageHead property.\n\n  };\n\n  loadImage.parseMetaData = function (file, callback, options, data) {\n    options = options || {};\n    data = data || {};\n    var that = this; // 256 KiB should contain all EXIF/ICC/IPTC segments:\n\n    var maxMetaDataSize = options.maxMetaDataSize || 262144;\n    var noMetaData = !(typeof DataView !== 'undefined' && file && file.size >= 12 && file.type === 'image/jpeg' && loadImage.blobSlice);\n\n    if (noMetaData || !loadImage.readFile(loadImage.blobSlice.call(file, 0, maxMetaDataSize), function (e) {\n      if (e.target.error) {\n        // FileReader error\n        console.log(e.target.error);\n        callback(data);\n        return;\n      } // Note on endianness:\n      // Since the marker and length bytes in JPEG files are always\n      // stored in big endian order, we can leave the endian parameter\n      // of the DataView methods undefined, defaulting to big endian.\n\n\n      var buffer = e.target.result;\n      var dataView = new DataView(buffer);\n      var offset = 2;\n      var maxOffset = dataView.byteLength - 4;\n      var headLength = offset;\n      var markerBytes;\n      var markerLength;\n      var parsers;\n      var i; // Check for the JPEG marker (0xffd8):\n\n      if (dataView.getUint16(0) === 0xffd8) {\n        while (offset < maxOffset) {\n          markerBytes = dataView.getUint16(offset); // Search for APPn (0xffeN) and COM (0xfffe) markers,\n          // which contain application-specific meta-data like\n          // Exif, ICC and IPTC data and text comments:\n\n          if (markerBytes >= 0xffe0 && markerBytes <= 0xffef || markerBytes === 0xfffe) {\n            // The marker bytes (2) are always followed by\n            // the length bytes (2), indicating the length of the\n            // marker segment, which includes the length bytes,\n            // but not the marker bytes, so we add 2:\n            markerLength = dataView.getUint16(offset + 2) + 2;\n\n            if (offset + markerLength > dataView.byteLength) {\n              console.log('Invalid meta data: Invalid segment size.');\n              break;\n            }\n\n            parsers = loadImage.metaDataParsers.jpeg[markerBytes];\n\n            if (parsers) {\n              for (i = 0; i < parsers.length; i += 1) {\n                parsers[i].call(that, dataView, offset, markerLength, data, options);\n              }\n            }\n\n            offset += markerLength;\n            headLength = offset;\n          } else {\n            // Not an APPn or COM marker, probably safe to\n            // assume that this is the end of the meta data\n            break;\n          }\n        } // Meta length must be longer than JPEG marker (2)\n        // plus APPn marker (2), followed by length bytes (2):\n\n\n        if (!options.disableImageHead && headLength > 6) {\n          if (buffer.slice) {\n            data.imageHead = buffer.slice(0, headLength);\n          } else {\n            // Workaround for IE10, which does not yet\n            // support ArrayBuffer.slice:\n            data.imageHead = new Uint8Array(buffer).subarray(0, headLength);\n          }\n        }\n      } else {\n        console.log('Invalid JPEG file: Missing JPEG marker.');\n      }\n\n      callback(data);\n    }, 'readAsArrayBuffer')) {\n      callback(data);\n    }\n  }; // Determines if meta data should be loaded automatically:\n\n\n  loadImage.hasMetaOption = function (options) {\n    return options && options.meta;\n  };\n\n  var originalTransform = loadImage.transform;\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.hasMetaOption(options)) {\n      loadImage.parseMetaData(file, function (data) {\n        originalTransform.call(loadImage, img, options, callback, file, data);\n      }, options, data);\n    } else {\n      originalTransform.apply(loadImage, arguments);\n    }\n  };\n});"],"sourceRoot":""}